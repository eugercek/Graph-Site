(()=>{"use strict";class e{constructor(e=[]){this.queue=e}enqueue(e){this.queue.push(e)}dequeue(){return this.queue.shift()}isEmpty(){return 0===this.queue.length}front(){if(this.isEmpty())throw new Error("Queue is empty!");return this.queue[0]}}const t=new class{constructor(e){this.size=e,this.adjacencyList=Array.from(Array(this.size),(()=>[]))}addEdge(e,t){this.adjacencyList[e].push(t)}toString(){console.table(this.adjacencyList)}}(7),o="Adjacency List",i="Depth First Traversal",n="Is Cyclic?",s="Breadth First Traversal",r="List all cycles",a="Prim's algorithm";t.addEdge(0,1),t.addEdge(1,2),t.addEdge(1,5),t.addEdge(2,0),t.addEdge(2,3),t.addEdge(3,4),t.addEdge(4,0),t.addEdge(4,6),t.addEdge(5,6),console.group(o),console.dir(t.adjacencyList),console.groupEnd(o),console.group(i),function(e,t=0){const o=new Array(e.size).fill(!1),i=t=>{o[t]||(console.log(t),o[t]=!0,e.adjacencyList[t].forEach((e=>{i(e)})))};i(t)}(t),console.groupEnd(i),console.group(s),function(t,o=0){const i=new e,n=new Array(t.size).fill(!1);for(i.enqueue(o),n[o]=!0;!i.isEmpty();){const e=i.dequeue();console.log(e),t.adjacencyList[e].forEach((e=>{!1===n[e]&&(i.enqueue(e),n[e]=!0)}))}}(t),console.groupEnd(s),console.group(n);const c=function(e){const t=new Array(e.size).fill(!1),o=new Array(e.size).fill(!1),i=n=>o[n]?(console.log(n),!0):!t[n]&&(t[n]=!0,o[n]=!0,console.log(n),!!e.adjacencyList[n].some((e=>i(e)))||(o[n]=!1,!1));for(let t=0;t<e.adjacencyList.length;t+=1)if(i(t))return!0;return!1}(t);console.log(c),console.groupEnd(n),console.group(r);const d=function(e){const t=new Array(e.size).fill(!1),o=new Array(e.size).fill(!1),i=[];let n=0;const s=r=>{if(o[r])return console.log(i),void(n+=1);!1===t[r]&&(t[r]=!0,o[r]=!0,i.push(r),e.adjacencyList[r].forEach((e=>s(e))),o[r]=!1,i.pop(r))};for(let t=0;t<e.adjacencyList.length;t+=1)s(t);return n}(t);console.log(d),console.groupEnd(r);const l=new class{constructor(e){this.size=e,this.adjacencyMatrix=new Array(e);for(let t=0;t<this.adjacencyMatrix.length;t+=1)this.adjacencyMatrix[t]=new Array(e).fill(0)}addEdgeWithWeight(e,t,o){this.adjacencyMatrix[e][t]=o,this.adjacencyMatrix[t][e]=o}toString(){console.table(this.adjacencyMatrix)}}(7);l.addEdgeWithWeight(0,1,12),l.addEdgeWithWeight(1,2,13),l.addEdgeWithWeight(1,5,11),l.addEdgeWithWeight(2,0,11),l.addEdgeWithWeight(2,3,18),l.addEdgeWithWeight(3,4,15),l.addEdgeWithWeight(4,0,17),l.addEdgeWithWeight(4,6,110),l.addEdgeWithWeight(5,6,12),console.group(a),function(e){const t=new Array(e.size).fill(Number.MAX_SAFE_INTEGER),o=new Array(e.size).fill(!1),i=new Array(e.size),n=()=>{let i,n=Number.MAX_SAFE_INTEGER;for(let s=0;s<e.size;s++)!1===o[s]&&t[s]<n&&(i=s,n=t[s]);return i};t[0]=0,i[0]=-1;for(let s=0;s<e.size-1;s++){const s=n();o[s]=!0;for(let n=0;n<e.size;n++)e.adjacencyMatrix[s][n]&&!1===o[n]&&e.adjacencyMatrix[s][n]<t[n]&&(t[n]=e.adjacencyMatrix[s][n],i[n]=s)}(()=>{for(let t=1;t<e.size;t++)console.log(`${i[t]} ->  ${t} (${e.adjacencyMatrix[t][i[t]]})`)})()}(l),console.groupEnd(a)})();